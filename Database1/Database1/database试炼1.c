
//顺序表：用一段地址连续的存储单元依次存储数据元素的线性结构
//严格来说数组不属于顺序表（狭义）
//顺序表要求元素是紧紧相连的

//int arr[10];
//arr[3] = 10;
//顺序表则不能从中间开始，只能从第一个位置开始存储

//地址连续的空间，一般情况下采用数组，但数组有静态数组和动态数组，
//所以顺序表分为：静态顺序表和动态顺序表


#include"SeqList.h"

int main()
{
	Test();
	system("pause");
	return 0;
}


//多线程：
//      线程是什么？
//      线程是进程中的一条执行流，linux下线程是以进程的pcb模拟的，所以说linux下的线程是轻量级进程，因此Linux下的线程是cpu调度的基本单位。
//      linux下的线程组成了线程组，进程id==线程组id，所以才说linux下的进程组是线程组，资源是分配给整个线程组的，所以进程是资源分配的基本单位，
//      并且进程中的线程共享大部分进程的资源。
//      因为进程中的线程共享虚拟地址空间：共享代码段和数据段。
//      文件描述符表，信号处理方式，工作目录，用户id
//      线程不仅共享进程这些资源，并且还独有一些资源：栈，上下文数据
//      线程和进程的优缺点：
//                         线程间通信非常方便，资源成本低，缺乏访问控制--想成需要考虑更多
//                         进程因为独立性所以健壮性比较强，通信麻烦，资源成本高
//      线程控制：
//               线程创建：pthread_reate
//               tid  pid  tgid==主线程pid
//               线程终止：
//                         return (main中不能return) ， pthread_exit, pthread_canel
//              线程等待：
//                        获取其他普通线程的退出返回值，避免产生僵尸线程
//                        pthread_join  只有线程处于joinable状态（线程默认属性），这个线程才能被等待。
//              线程分离：
//                        线程退出后，直接释放资源，无法获取返回值。
//                        pthread_detach       设置线程的属性为分离属性(detach)，退出后直接释放资源
//                        只有在我们不关心线程的退出返回值的时候才会设置，因为一旦设置就无法pthread_join。
//              线程安全：          
//                        多个线程因为临界资源的争抢写入操作会导致程序逻辑的混乱/数据二义性，因此就引入了线程安全的概念
//                        但是线程的使用本身就是因为线程间的通信方便以及成本低而广为使用，这样的话就无法避免大量临界资源的争抢操作，这时候就必须要考虑
//              如何保证线程安全
//                        保证线程安全更多指的是保证数据的安全访问（互斥/同步）
//              线程间如何实现同步与互斥？？？
//                        互斥：互斥锁---保证数据同一时间的唯一访问
//                        抢票系统    
//              死锁：
//                    一个程序一直获取不到锁，因此一直处于卡死状态称为死锁
//              死锁产生的四个必要条件：
//                                      1.互斥条件：
//                                                 只有一个人可以获取锁
//                                  *   2.请求与保持条件：
//                                                       拿到了第一个锁，去请求第二个锁的时候，拿不到但是还不释放第一个
//                                      3.不可剥夺条件：
//                                                     我的锁别人不可释放
//                                  *   4.环路等待条件：
//                                                     我拿着我的锁，去请求你的锁，你拿着你的锁去请求我的锁。
//              预防死锁就是破坏死锁条件。
//                    
//              避免死锁的算法：
//                             1.银行家算法
//                             2.死锁检测算法
//              互斥锁没有时序：
//                             1.没有条件判断
//                             2.没有通知
//                             pthread_cond_init
//                             pthread_cond_wait     等待
//                             pthread_cond_signal   通知
//                                                   通知等待在条件变量上的线程/进程
//              同步：条件变量---让数据的访问更加具有时序的可控性
//                        
//
//
//
//
//
//
//
//
//
